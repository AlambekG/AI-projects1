
Name&ID: Alambek Gulamidinov 20192012
Email: alambek@unist.ac.kr
  
BFS:
  BFS implemented with list of queue which adds elements to the back and traverse starting 
  from the front of list, so that we enter closest elements first
  Backtracking was made with unordered_map for storing parents values.

  1) Yes, it worked in all test cases generated by maze program.
  2) The number of states are equal to the number of moves.
  3) MAX of MAZE size 300x300 works fine

DFS:
  Dfs implemented using list (without recursion)
  unlike BFS, dfs will add elements to the front and start traversing through the list
  also from front - so that it will go till depth of every entry. 
  Unordered_map dist used to store distance from start to current position,
  storing distance makes possible finding the shortest path,
  Backtracking was made with unordered_map for storing parents values.

  For finding Shortest path I stored distance and I was looking only for elements that 
  have not visited yet or distance to that elements are larger then it should be, and I 
  updated parent every time I found shorter distance

  For Optimization I used some trick. I figured out that on average the Maximum length of shortest 
  path is not bigger than (Sum of Maze size + half sum of maze size). So, I dont traverse elements
  if its exceeding value of Approximate Shortest path length. It allowed my program to run for big size 
  Mazes. Its accuraccy is also fine, it could fail only on corner cases.
  
  1) Yes, it worked almost in all of the cases
  2) Number of moves a larger than number of states. However I think it's okay, since DFS is not efficcient for
  finding Shortest path. 
  3) It worked very slow, however it gave result for 300X300 within 2 minutes. 

A*:
  A* search algorithm implemented with set (closed set, for not entering already visited elements)
  and the main set is where we store elements in the sorted order of distance: (H value and distance from start to
  the that position) every time 
  Since we couldn't know H value untill we get into the position, list Q is used.
  Q adds element and then the program puts values with its H into our main set and closed set.
  Backtracking was made with unordered_map for storing parent values

  1) Yes, it works fine in all cases. However sometimes in big sized mazes it can give not the shortest
  path but very close value. I think it is due to the H-value error.
  2) The number of moves a bit larger than number of states since my algorithm sorts elements 
    when it gets H values and for getting current values sensory data it sends the first element of set to the 
    simulator. But this difference is very miserable
  3) MAX of maze allowed size 300x300 works fine